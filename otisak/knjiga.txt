C sa klasama:
Strukture definišu samo moguće vrednosti za definisane podatke.
Klase definišu i moguće operacije nad tim podacima. Jedine operacije nad podacima date klase mogu da budu samo one koje su predviđene definicijom te klase.

Dodavanjem virtuelnih funkcija i preklapanja operatora, nastaje C++.
Kasnije je dodato višestruko nasleđivanje, apstraktne klase, mehanizmi za sastavljanje generičkih klasa i za rukovanje izuzecima.

KADA JE JEZIK ČISTO OBJEKTAN, NE POSTOJE SLOBODNE (STATIC) FUNCKIJE JER NE POSTOJE KONSTANTE NITI KONSTANTNI OBJEKTI
JAVA IMA STATIČKE METODE KOJE SU PO KARAKTERISTIKAMA ISTE KAO SLOBODNE FUNKCIJE SAMO ŠTO IMAJU DRUGAČIJI NAZIV

//// C ////

U bele znakove spadaju znak za razmak, tabulacija, vertikalna tabulacija, prelazak u novi red i prelazak na novi list.
U širem smislu, u bele znakove se ubrajaju i komentari.

Nabrojane konstante (enum) su celobrojne konstante koje se definišu nabrajanjem u naredbama nabrajanja.
Prva konstanta u enumeraciji ima vrednost 0 (osim ako nije eksplicitno naznačeno drugačije).

Za realne konstante se podrazumeva tip podataka double. (ne float, DOUBLE) (sufiks L).

Dodela početne vrednosti pri definiciji podatka se naziva inicijalizacija.

Izvedeni tipovi podataka u C-u su: pokazivači, nizovi, strukture, unije i strukture od bitova.

Pokazivači mogu da smeste adresu podatka ili potprograma u operativnoj memoriji.
Svi pokazivači su iste veličine, bez obzira na koji tip podataka pokazuju.
Dva pokazivača su istog tipa ako pokazuju na podatke istih tipova. 
Dozvoljeno je oduzeti vrednosti dva pokazivača koji pokazuju na elemente istog niza (dobijamo razliku indeksa ta dva elementa u datom nizu).
Dozvoljeno je i upoređivanje dva pokazivača relacijskim operatorima, ali to ima smisla samo ako oni pokazuju na elemente istog niza.

Nizovi su složeni tipovi podatak koji se sastoje od više elemenata međusobno jednakih tipova.
String ne postoji kao poseban tip podataka, nego se umesto njega koristi char[] na čijem se kraju nalazi dodatan element '\0'.

Strukture su složeni tipovi podataka koji se sastoje od uređenih nizova elemenata koji mogu da budu međusobno različitih tipova.
Ti elementi zovu se polja strukture. Oni se obeležavaju identifikatorima.

Unije su složeni tipovi podataka koji omogućavaju da se u istom memorijskom prostoru, u različitim trenucima, smeštaju podaci različitih tipova.
Početna vrednost unije može da se dodeli samo prvom članu date unije.

Bitski operatori postoje samo u jeziku C i u jezicima koji su proizašli iz njega (C++, Java).
Uslovni operator (?:) je specifičan ternarni operator jezika C.

Operatori za dodelu vrednosti su, takođe, jedna od specifičnosti jezika C. 
U drugim jezicima je to naredba, dok je u to C-u operator (=), i zbog toga može da bude i više dodeljivanja vrednosti u sastavu istog izraza (naredbe).
Strukture se mogu međusobno dodeljivati operatorom dodele vrednosti (=).

Operator zarez (,) služi za lančanje izraza.

Indeksiranje se smatra binarnim operatorom ([]), gde se u izrazu a[b] a odnosi na niz, a b na indeks traženog elementa u tom nizu.
a[b] == *(a+b)
&a[b] == (a+b)
Identifikator niza predstavlja pokazivač na prvi element tog niza.

Pristup poljima struktura i unija se vrši binarnim operatorima . ili ->
Prvi operand operatora . treba da bude podatak, a drugi operand treba da bude Identifikator polja strukture ili unije.
Prvi operand operatora -> treba da bude pokazivač, a drugi operand treba da bude Identifikator polja strukture ili unije.
a->b == (*a).b

Pozivanje funkcije u jeziku C se smatra binarnim operatorom.
Prvi operand je pozivana funkcija predstavljena identifikatorom ili adresnim izrazom, a drugi operand je niz argumenata.

Ako su operandi nekog operatora različitog tipa, vrši se automatska konverzija "jednostavnijeg" tipa operanda u "složeniji" tip i onda se izračunava rezultat operatora.
U slučaju pokazivača, dodela vrednosti je dozvoljena samo ako su oba operanda pokazivači na podatke istih tipova, osim ako je jedan od operanada generički pokazivač (void*).
U ostalim slučajevima, mora da bude eksplicitno naznačena konverzija tipa dodeljivanog pokazivača.

Prosta naredba: izraz;
Složena naredba (upravljačka struktrua): sekvence ({}), selekcije (if, switch...), ciklusi i petlje (while, for, do).
Upravljačke naredbe: skokovi (break, continue, goto).

Programski jezik C, po pravilu, priznaje samo jednu vrstu potprograma koji se nazivaju funkcije.
Funkcija, na osnovu izvesnog broja parametara, daju jedan razultat - vrednost funkcije. U C-u funkcije mogu da proizvode i bočne efekte.
Tip funkcije mogu da budu osnovi tipovi, strukture, unije, pokazivačkog tipa i tipa void, ali ne može da bude tipa niza.
Parametri funkcije smatraju se lokalnim podacima.
Prilikom definisanja funkcije se moraju napisati i tipovi identifikatori argumenata funkcija.
Prilikom deklaracije funkcije pišu se samo tipovi agrumenata, ne i njihovi identifikatori. To su prototipovi funkcija.
Iako funkcije nisu podaci, mogu da se definišu pokazivači na funkcije.

Glavna funkcija u jeziku C može imati prototip:
void main (void);
int  main (void);
void main (int bpar, char* vpar[]);
int  main (int bpar, char* vpar[]);

Podaci definisani izvan svih funkcija predstavljaju globalne podatke.
Oni mogu da se deklarišu proizvoljan broj puta i da se definišu tačno jednom.
Funkcije su uvek globalne. 
I one mogu da se deklarišu više puta i definišu tačno jednom.

Doseg identifikatora predstavlja deo programa unutar kojeg identifikator može da se koristi.
Identifikatori mogu da se koriste od mesta definisanja do kraja dosega.
Postoji pet vrsta dosega: 
 datotečki (definisani izvan funkcija - globalni),
 blokovski (unutar bloka - lokalni),
 funkcijski (samo oznake za skokove naredbama goto - proteže se na celo telo funckije),
 protoripski (parametri u prototipovima funckija),
 strukturni (identifikatori članova strutkura ili unija).

Način povezivanja označava način na koji se povezuju isti globalni identifikatori, korišćeni u različitim datotekama.
Isti identifikatori sa spoljašnjim povezivanjem označavaju isti podatak ili funkciju unutar svih datoteka programskog sistema.
Identifikatori sa unutrašnjim povezivanjem su lokalni za datoteke u kojima su definisani, pa u svakoj datoteci predstavljaju međusobno nezavisne podatke ili funkcije.
Globalni identifikatori funkcija i podataka imaju spoljašnje povezivanje, izuzev kada se prilikom njihovog definisanja koristi modifikator static.
Globalni identifikatori uvedeni naredbama typedef ili enum uvek imaju unutrašnje povezivanje.
Kod lokalnim identifikatora ne postoji pojam povezivanja, izuzev kada se prilikom njihovog deklarisanja ne koristi modifikator extern i tada imaju blokovski doseg.

Po trajnosti podaci mogu da se dele u četiri grupe:
 trajni podaci (od momenta stvaranja do kraja programa) (trajni podaci imaju nulte početne vrednosti) 
 [lokalni podaci mogu da se pretvore u trajne upotrebom modifikatora static],
 prolazni podaci (od momenta definisanja do kraja dosega njihovih identifikatora),
 privremeni podaci (u toku izvršavanja složenog izraza u kom služe za čuvanje međurezultata),
 dinamički podaci (stvara ih i uništava sam programer) (može da im se pristupi samo pokazivačima i imaju slućajne početne vrednosti).


//// C++ ////

Glavna razlika od C-a je uvođenje klasa sa svim pretećim konceptima.
Uveden je logički tip bool sa dve moguće vrednosti: true i false. Postoji automatska konverzija između tipa bool i numeričkih tipova.
Znakovne konstante poput 'A' u jeziku C su tipa int, a u jeziku C++ su tipa char.
Uvode se simboličke konstante, upotrebom modifikatora const. Ovim se smanjuje potreba za korišćenjem pretprocesorke direktive #define.

Izrazom za postavljanje početnih vrednosti u naredbi for mogu da se definišu nekoliko promenljivih međusobno jednakog numeričkog ili pokazivačkog tipa.

Identifikatori nabrajanja, struktura i unija u jeziku C++ mogu da se koriste kao identifikatori tipa bez službenih reči, pod uslovom da su jedinstveni u svojim dosezima.
Ukoliko u datom opsegu s istim identifikatorom istovremeno postoji neki podatak, nabrajanje ili struktura/unija, identifikator sam označava podatak. Potrebna je ključna reč ispred.

Svako nabrajanje u C++ je celobrojan tip podataka koji definiše niz simboličkih konstanti.
Sva nabrajanja se smatraju različitim tipovima, kako međusobno, tako i u odnosu na osnovne celobrojne tipove char, int, short i long.
Za podatke tipova nabrajanja nije definisana nijedna operacija osim dodele vrednosti tipa nabrajanja promenljivoj tipa istog nabrajanja.
Podaci tipa nabrajanja mogu da se koriste u aritmetičkim i relacijskim izrazima, i tada se automatski pretvaraju u tip int pre izračunavanja.
enum Dani = {PO, UT, SR, CE, PE, SU, NE}; 
Dani dan = SR; 
dan++;                      // ovo je greska (++ je definisan za tip podataka int, ali ne i za tip podataka Dani) !!!
dan = (Dani) (dan + 1);     // ovo je ispravno

Modifikator mutable ispred nekog polja strukture dozvoljava promenu tog polja čak i u nepromenljivim (const) delovima te strukture.

Bezimene unije predstavljaju jedan bezimeni podatak. Unije sa imenima su tipovi podataka.
Identifikatori članova imaju datotečki ili blokovski doseg.

Pokazivaču na podatke poznatih tipova u jeziku C++ ne može da se dodeli vrednost generičkog pokazivača.
To se može uraditi samo eksplicitnom konverzijom.

Upućivač (referenca) u jeziku C++ je alternativno ime za neki podatak.
Reference ne zauzimaju prostor u memoriji, ne može da se dobije njihova adresa, ne postoje pokazivači na reference, niti nizovi referenci.
Reference moraju da se inicijalizuju prilikom definisanja nekim podatkom koji se nalazi u memoriji, jer kasnije ne može da im se promeni vrednost.
Sve operacije nad referencama deluju na podatke kojima su pridruženi, a ne na same reference.
Svako pominjanje reference podrazumeva posredan pristup do upućivanog podatka. Kod pokazivača je potrebno koristiti operator za indirektno adresiranje.
Reference se definišu upotrebom modifikatora & ispred identifikatora reference.
Reference mogu, kao i pokazivači, da upućuju na promenljive, nepromenljive i nepostojane podatke.
Promenljiv podatak ne može da se promeni nepromenljivom referencom.
Referencama se pomoću typedef mogu pridružiti imena na isti način kao i ostalim tipovima podataka.
Reference mogu da budu parametri i vrednosti funkcija.
Inicijalizacija reference kao parametra ne dovodi do kopiranja argumenta u parametar, čime se štedi i memorijski prostor i vreme.
void povecaj (int& a) {a++;}
int x = 1;
povecaj(x);     // u redu je
povecaj(x+1);   // GRESKA!
Kod funkcija čija vrednost nije referenca, rezultat je kopija vrednosti izraza u naredbni return. 
To je samo kopija vrednosti te promenljive, a ne promenljiva koja će kasnije moći da se menja.
Vrednost funkcije ne sme biti referenca na lokalan prolazan podatak jer će taj podatak biti uništen prilikom napuštanja funkcije.

Postfiksne varijante operatora imaju za jedan nivo viši prioritet nego prefiksne varijante (primer ++x i x++).

Izvorište podataka odakle program može da čita potrebne podatke u jeziku C++ se nazivaju ulazni tokovi.
Odredišta podataka na koja program može da pošalje svoje rezultate nazivaju se izlazni tokovi.
Na početku izvršavanja programa automatski se stvaraju sledeće dve globalne promenljive tipa tokova: cin i cout.

Za potrebe dodele memorije u dinamičkoj zoni memorije u vreme izvršavanja programa u jeziku C++, dodati su operatori new i delete.
Veličina dodeljenog prostora pomoću operatora new se automatski određuje na osnovu veličine stvaranog podatka.
Tip vrednosti operatora new je uvek pokazivač na upravo stvoreni podatak (a ne void* kao kod malloc, calloc i realloc).
Operatorom new se mogu postaviti poćetne vrednosti stvaranim podacima po želji.
Sadržaj niza ne može da se inicijalizuje prilikom dinamičke dodele memorije.
Sa operatorom new je moguće stvarati i nizove podataka.
Ako dodela memorije ne uspe, greška se prijavljuje izuzetkom tipa bad_alloc (ranije se vraćao samo NULL pokazivač).
Opšti slućaj oslobađanja memorije u dinamičkoj zoni je: delete pokazivač; delete[] niz;
U slučaju nizova, mora se osloboditi ceo niz, ne samo jedan element iz njega.
Primenom operatora delete se ne dobija nikakav rezultat (tip void).

Prilikom definisanja funkcija u jeziku C++ mogu da se navedu podrazumevane vrednosti za neke parametre.
Te vrednosti će se koristiti kao početne vrednosti nekih parametara u slučaju da u pozivu funkcije nedostaju odgovarajuči argumenti.
Ako se za neki parametar navodi početna vrednost, to mora da se uradi i za sve parametre iza njega.
Ako se za neku funkciju predvide podrazumevane vrednosti za sve parametre funkcije, ona može da se poziva i bez argumenata.

Mehanizam preklapanja funkcija u C++ omogućava da se srodnim funkcijama daju ista imena.
Funkcije imaju iste identifikatore, ali moraju međusobno da se razlikuju po broju i/ili tipovima parametara. Tipovi vrednosti funkcija mogu da budu međusobno jednaki.

U jeziku C++ predviđena je mogućnost povezivanja potprograma pisanih na drugim jezicima.
Pošto se u C++ zahteva bar deklaracija svih funkcija pre njihovog prvog povezivanja, to se zahteva i za funkcije koje su pisane na drugim jezicima.
extern "jezik" deklaracija;

Prostori imena grupišu globalna imena u velikim programskim sistemima u više dosega. Svaki prostor imena čini zaseban doseg, takozvani prostorski doseg.
Ako se delovi programa stave u različite prostore imena ne može doći do konflikta pri koriščenju imena.
Prostori imena su otvoreni. Dati identifikator može da se koristi u više definicija prostora imena. Svaka nova definicija će dodati novi sadržaj prostoru imena sa tim identifikatorom.
Sadržaj prostora imena se ne prenosi iz datoteke u datoteku.
Identifikatori unutar nekog prostora imena mogu da se dohvate iz bilo kog dela programa koriščenjem operatora za razrešenje dosega (::).
Kada koristimo dva prostora imena sa promenljivama koje imaju iste identifikatore, ispred njih moramo da naznačimo kom prostoru imena one pripadaju.
Bezimeni prostor imena ne čini zaseban prostor imena nego se utapa u okružujući datotečki doseg.
Globalni identifikatori iz bezimenog prostora imena može da se dohvati sve dok se isti identifikator ne uveze iz drugog prostora imena.
Sva Standardom predviđena zaglavlja sve globalne identifikatore stavljaju u prostor imena std (stdout, stdin, endl...).
Najbolje je prvo koristiti #include direktive, pa tek onda using namespace direktivu. Tako će sva potrebna imena postati odjednom raspoloživa.

Klase u jeziku C++ su složeni tipovi podataka koji se sastoje od uređenih nizova elemenata koji mogu da budu međusobno različitih tipova. Ti elementi se nazivaju članovi klasa.
Pojam podatak obuhvata kako vrednosti standardnih tipova, tako i objekte klasnih tipova.
Jedino se razlikuju pojedinačni (skalarni) podaci i nizovi (vektori).

Članovi klasa mogu da budu podaci ili funkcije.
Vrednosti podataka članova klase čine stanje objekta i nazivaju se polja ili atributi klase (objekta).
Funkcije članovi služe za izvođenje raznih operacija nad poljima objekta čime menjaju stanje objekta na koji se primenjuju. Nazivaju se metode klase.
Članovi klase mogu da budu javni ili privatni.
Privatnim članovima može da se pristupa samo iz unutrašnjosti posmatrane klase. 
Privatna polja klase mogu da koriste ili menjaju samo metode date klase. 
Privatne metode mogu da pozivaju samo druge metode iste klase.
Javnim članovima može da se pristupa bez ograničenja kako iz unutrašnosti klase, tako i iz ostatka programa izvan posmatrane klase.
Ove osobine označavaju prava pristupanja ili vidljivost članova.

Klase su pravi tipovi jer:
 određuju moguće vrednosti objekata
 određuju moguće operacije nad objektima
 sprečavaju izvršavanje bilo koje druge operacije nad objektima
 obezbeđuju obaveznu inicijalizaciju stvaranih objekata (dodelu početnih vrednosti)
 obezbeđuju uništavanje objekata kada više nisu potrebni

Definicija klase predstavlja navođenje svih članova klase. 
Na osnovu definicije mora da se zna veličina potrebnog memorijskog prostora za smeštanje pojedinih objekata tipa te klase.
Deklaracijom klase samo se naznači da neki identifikator predstavlja klasu, ali se ništa ne kaže o sadržaju klase.
Posle deklaracije klase mogu da se definišu pokazivači i reference na objekte tipa te klase, ali ne mogu da se definišu objekti tipa te klase, niti da se pristupa članovima klase.
Pri definisanju objekata dodeljuje se i memorija, pa je potrebno da se zna veličina objekata, a pri pristupanja članovima potrebno je da se zna koji članovi postoje.
Identifikator klase ima status identifikatora tipa.

Javni i privatni delovi klase se razgraničavaju sa oznakama public i private.
Početni deo klase, pre prve oznake public, je privatan. 
Član u definiciji klase može da bude:
 definicija polja u obliku naredbe za definisanje podataka (ne mogu da se navedu inicjalizatori) (polja ne mogu da budu nepostojana) 
 (polja mogu da budu i pokazivači ili reference na primerke te klase, ali ne mogu da budu objekti tipa klase koja se definiše)
 definicija metode (podrazumeva se modifikator inline) 
 deklaracije metode (mogu da budu definisane negde izvan definicije te klase) (mogu biti ugrađene, ali se podrazumeva modifikator inline)
 naredbe typedef i enum (uvode identifikatore tipa, ali ne i stvaraju članove klase) (ne utiču ni na veličinu objekata ni na funkcionalnost klase)
Članovi klase imaju klasni doseg (od mesta definisanja, do kraja klase).

Posle definisanja klase se podrazumeva dostupnost sledećih operacija nad objektima te klase:
 definisanje (stvaranje) objekata i nizova objekata
 definisanje pokazivača i referenci na objekte
 dodeljivanje vrednosti jednog objekta drugom
 nalaženje adresa objekata i pristup objektima na osnovu adrese ili indeksiranjem
 pristup članovima objekta neposredno ili posredno

Objekti mogu biti parametri funkcije kao i vrednosti funkcija.
Objekti kao parametri funckija se prenose pomoću vrednosti, a ako to ne odgovara, treba koristiti pokazivače ili reference.
Postoje slučajevi kada identifikatori klasnog dosega mogu da se koriste i izvan njihove klase bez pominjanja konkretnog objekta. 
Takvi su npr. identifikatori uvedeni naredbama typedef ili enum, i oni mogu da se dohvate upotrebom operatora za razrešenje dosega (::).

Metode klasa pored svojih parametara imaju još jedan "skriven" parametar - adresu objekta za koji je metoda pozvana.
Taj objekat se naziva i tekući objekat jer je to objekat koji metoda obrađuje.
Za pristupanje članocvima tekućeg objekta dovoljno je navesti samo identifikator člana.
Identifikator skirvenog člana u svakoj funkciji je this. Tip skrivenog parametra u svakoj klasi je nepromenljiv pokazivač na tu klasu.
Tekući objekat u celini može da se dohvati posrednim pristupom pomoću izraza *this.
Pokazivač this se eksplicitno koristi veoma retko. Uglavnom se koristi samo ako tekući objekat treba da bude vrednost funkcije metode koja se upravo izvršava.
Drugi primer korišćenja je kada tekući objekat ili njegova adresa treba da bude argument neke funkcije, ili ako tekući objekat treba da se priključi u neku ulančanu listu.

Novi objekti mogu da se stvaraju:
 izvršavanjem naredbi za definisanje podataka 
 stvaranjem lokalnih podataka za parametre prilikom pozivanja funkcija
 u toku izvršavanja složenih funkcija za odlaganje međurezultata
 izvršavanjem operatora new (dinamički objekti)
Stvaranje objekata podrazumeva dodelu memorijskog prostora, i, eventualno, inicijalizaciju dodeljivanjem nekih početnih vrednosti.
memorijski prostor se dodeljuje automatski za sva polja klasa prema definiciji klasa.
Inicijalizaciju polja treba da predvidi programer (osim kod trajnih (static) objekata gde se podrazumeva vrednost 0 za sva polja klase).

Neke vrste objekata programer nikako ne može da inicjalizuje ručno.
Mehanizam koji C++ nudi za rešavanje ovog problema su konstruktori. Oni garantuju stvaranje svih vrsta objekata neke klase (trajni, prolazni, dinamički...).
To su specijalne metode koje se pozivaju automatski kad god se stvara neki objekat date klase, bez obzira na koju vrstu objekata se odnosi.
Neinicijalizovan objekat nije objekat, nego samo parče memorije čiji sadržaj nema nikakvog smisla.
Zadatak konstruktora je da to parče memorije pretvori u objekat sa svim obeležjima svoje klase.
Konstrutkori imaju iste identifikatore kao i klase kojima pripadaju.

Data klasa može da ima više konstruktora. Preklapanje imena funkcija je dozvoljena i za slučaj konstruktora.
Konstruktori mogu da imaju proizvoljan broj parametara, a mogu da budu i bez ijednog parametra.
Parametar konstruktora ne može da bude tipa svoje klase, ali može biti pokazivač ili referenca na primerke sopstvene klase.
Konstruktori mogu da imaju podrazumevane parametre. Ne daju nikakvu vrednost funkcija.
Razlika pri deklarisanju konstruktora i običnih funkcija i metoda je nedostatak oznake tipa rezultata.
Konstruktori se pozivaju automatski i prilikom dodeljivanja memorije u dinamičkoj zoni operatorom new.
Konstruktori mogu da se pozivaju i eksplicitno. Rezultat je tada bezimeni primerak klase koji se smatra privremenim objektom.
specifičnosti definisanja konstruktora je mogućnost navođenja niza inicijalizatora između niza parametara i tela konstruktora (: pa ono iza toga).

Ne mogu da se navedu inicijalizatori za zajednička polja klase, jer se ona ne stvaraju prilikom stvaranja primeraka klase.
Međutim, nema nikakvih prepreka da se vrednost zajedničkih polja klase promene u telu konstruktora.

Ako u klasi postoji konstruktor koji može da se poziva bez argumenata, pozivaće se kad god se stvara objekat bez inicijalizatora.
To je podrazumevani konstruktor i njegovo postojanje podrazumeva garanciju da će svi primerci date klase biti inicijalizovani, čak i kada programer to ne traži eksplicitno.
Ako u nekoj klasi nije napisan ni jedan konstruktor, podrazumevani konstruktor se generiše sa praznim telom i to kao javan konstruktor.
Ako je u klasi definisan bar jedan konstruktor, podrazumevani konstruktor se ne generiše, ali to ne znači da ne smemo eksplicitno da definišemo podrazumevani konstruktor sa praznim telom.
U klasama koja poseduju pokazivačka polja, obavezna je njihova inicijalizacija.
Kako bi se sprečilo automatsko generisanje javnih podrazumevanih konstrutkora, unutar klase se treba napraviti privatan podrazumevani konstruktor sa praznim telom.

Konstruktor kopije je konstruktor koji može da se poziva sa jednim argumentom tipa svoje klase. 
Taj parametar, u definiciji konstruktora, mora biti referenca na primerke klase.
Prilikom pozivanja konstruktora, parametar može biti sam objekat ili referenca na objekat.
Ako u klasi nije definisan konstruktor kopije, on se automatski generiše tako da kopira sadržaj svih polja drugog objekta. Tako generisani konstruktor je javan.
Automatski generisan konstrutor kopije ne sprečava automatska generisanje podrazumevanog konstruktora.
Ako su neka od polja pokazivači, generisani konstruktor će kopirati samo pokazivače, a neće praviti kopije pokazivanih objekata. 
To nije dobro (u slučaju dinamički zauzete memorije na primer).
Konstruktor kopije se automatski poziva prilikom inicijalizacije parametara funkcije.
Kao i za prazan konstruktor, može se definisati privatan konstruktor kopije ako nema smisla praviti kopije objekta i kom se može pristupati jedino iz same klase.

Konstruktor konverzije je konstruktor koji može da se pozove s jednim argumentom čiji tip nije jednak posmatranoj klasi.
Konstruktorima konverzije se može vršiti konverzija iz standardnih tipova u klasne tipove, ali ne i obrnuto.

Stvaranje objekata podrazumeva dodelu memorijskog prostora potrebne veličine i inicijalizaciju polja.
Polja klase mogu i sami da budu primerci nekih drugih klasa.
U toku stvaranja objekta najpre se inicijalizuju polja klasnih tipova po redosledu navođenja u definiciji klase (bez obzira na redosled navođenja inicijalizatora).
Ako za neko polje klasnog tipa postoji inicijalizator, on će se pozvati, a ako ne postoji, pozvaće se podrazumevani konstruktor.
Posle inicijalizacije polja klasnih tipova, inicijalizuju se polja standardnih tipova za koje postoji inicjalizator u definiciji konstruktora.
Redosled je, opet, po redosledu navođenja polja u definiciji klase, a ne inicijlizatora u definiciji konstruktora.
Na kraju se izvršava telo konstruktora. Menjanje polja unutar tela konstruktora se ne smatra inicijalizacijom, već dodelom vrednosti.
Ako se ne definiše dodela vrednosti za polja standardnih tipova, ta polja će ostati neinicijalizovana.
nepromenljivim poljima i referencama se vrednost može dodeliti/promeniti samo inicijalizatorima navedenim u definiciji konstruktora.

INICIJALIZACIJA: ONO POSLE DVE TAČKE POSLE IMENA KLASE TJ KONSTRUKTORA 
DODELA VREDNOSTI: ONO ŠTO SE DEŠAVA POSLE INICIJALIZACIJE, TJ SVE U VITIČASTIM ZAGRADAMA

Ako se pravi niz objekata, redosled inicijalizacije je po rastućim vrednostima indeksa.
Ako se memorija dodeljuje nizu objekata pomoću operatora new, koristiće se podrazumevani konstruktor za elemente niza (inicijalizator ne sme da se navodi).

Smatra se da i za proste tipove podataka postoje podrazumevani konstruktori, konstruktori kopije i konstruktori konverzije.
Podrazumevani konstruktor postavlja vrednost novog podatka na nulu odgovarajućeg tipa.
Podrazumevani konstruktor se nikada ne poziva automatski, nego samo eksplicitno.
Konstruktori kopije i konverzije mogu da se pozovu automatski, kao i eksplicitno.
Ovi konstruktori mogu da se koriste samo kod tipova čija se leksička oznaka sadrži iz samo jednog člana (npr int može, int* ne može).

Objekte koji više nisu potrebni treba ispravno uništiti.
Memorijski prostor koji je objektima dodeljen se automatski oslobađa pri uništavanju objekta.
Memorijski prostor koji se nalazi u dinamičkoj zoni mora eksplicitno da se oslobodi.
Posebne metode koje služe za uništavanje objekata se nazivaju destruktori.
Oni se automatski pozivaju, nemaju parametre. Klasa može da ima samo jedan destruktor.
Posle primene destruktora na nekom objektu, on gubi obeležja svoje klase i postaje samo parče memorije.
Destruktori imaju iste identifikatore kao i klase kojima pripadaju, sa dodatim ~ ispred.
Ako objekat koji se uništava ima destruktore za polja drugih klasa, prvo se izvršava telo tog destruktora, pa tek onda destruktori tih klasnih polja (suprotno od konstruktora).
Ako u klasi nije definisan destruktor, on se automatski generiše sa praznim telom. Generisani konstruktor je javan. On nije dobar za klase sa pokazivačkim poljima.
U slučaju niza objekata, destruktor se poziva sa kraja niza ka početku (po opadajućim adresama).
Destruktori mogu da se pozivaju i eksplicitno.

Konstante klasnih tipova ne postoje.

Stavljanjem modifikatora static na početak definicije ili deklaracije nekog člana date klase, taj član postaje zajednički za sve objekte te klase koji će kasnije biti stvoreni.
Članovi koji nisu zajednički se nazivaju pojedinačni članovi klase. Bez eksplicitnog zahteva, članovi klasa su pojedinačni članovi.
U slučaju zajedničkog člana, postojaće samo jedan primerak tog člana. Pristup tom polju iz bilo kog od tih objekata podrazumeva pristup istoj memorijskog lokaciji.
Zajednička polja se smatraju zasebnim trajnim podacima sa spoljašnjim povezivanjem. Njihov opis unutar klase se smatra samo deklaracijom, što ne obuhvata dodelu memorije.
Zajednička polja se definišu zasebnim naredbama za definisaje podataka koje se pišu izvan definicija klasa. Koristi se operator za razrešenje dosega.
U nedostatku inicijlizatora ovih polja, nule se podrazumevaju. Početne vrednosti se dodeljuju pre funkcije main().

Zajedničke metode ne poseduju pokazivač this. 
Navođenjem samo identifikatora člana, one mogu da pristupaju zajedničkim članovima klasa.
Pojedinačne metode mogu ravnopravno da koriste i pojedinačna i zajednička polja klasa.
Za pojedinačne članove se podrazumeva pristup pomoću pokazivača this, ali zajedničke metode ga ne poseduju, tako da im se ne može pristupiti preko njih.
Za pojedinačne metode se mora navesti konkretan objekat preko kog se pozivaju, dok je za zajedničke metode dovoljno navesti samo identifikator klase.

Prijateljske funkcije neke klase su funkcije koje nisu članovi te klase, ali imaju pravo pristupa privatnim članovima te klase.
One mogu da budu obične (globalne) funkcije ili da budu metode drugih klasa.
Da bi funkcija postala prijateljska funkcija neke klase, potrebno je u definiciji te klase navesti njen prototip ili definiciju sa modifikatorom friend ispred.
Nije bitno da li se funkcija proglašava prijateljskom u privatnom ili javnom delu klase, pošto ona nije član posmatrane klase.
Prijateljske funkcije ne poseduju pokazivač this i zato mogu da obrađuju samo konkretne objekte te klase.
Ako je prijateljska funkcija metoda neke druge klase, ona poseduje pokazivač this za svoju klasu.
Ista funkcija može da bude prijateljska funkcija za više klasa odjednom.

Pokazivači na polja klasa pokazuju na određeno polje primeraka klasa.
Tip pokazivača na članove neke klase je Klasa::*
Adresa polja klase se dobije pomoću operatora &Klasa::

Klase mogu da se definišu i unutar definicija drugih klasa. Identifikator tako definisane klase ima klasni doseg i proteže se do kraja definicije spoljašnje klase.
Iz unutrašnje klase ne mogu da se koriste privatni članovi spoljašnje klasa, i obrnuto (osim ako su jedna drugoj prijateljske klase).

Klase mogu da se definišu unutar funckija. Takve klase se nazivaju lokalne klase.
Metode lokalne klase moraju da se definišu unutar definicije klase.
Lokalna klasa ne može da ima zajednička članove.

Strukture u jeziku C++ su klase čiji su svi članovi podrazumevano javni.
Od toga može da se odstupa umetanjem oznaka private i public.
I strukture mogu da imaju metode.

Unije su specifične po tome što sva polja imaju iste početne adrese. Zbog toga samo jedna od njih može da ima definisanu vrednost.
I unije mogu da imaju metode, uključujući i konstruktore i destruktore.
Mogu da imaju private i public delove, s tim da je početni deo javan.
Konstruktori omogućuju da se unije inicijalizacuju preko nekih drugih polja, a ne preko samo prvih polja.
Unije ne mogu imati zajedničke (static) članove (polja i metode).
Unije ne mogu imati polja tipa klasa sa konstruktorima i destruktorima.
Bezimene unije ne mogu imati svoje metode, niti je dozvoljena upotreba private i public oznaka.

Najopštiji odnos među klasama se zove asocijacija. Među poljima jedne klase postoji polje koje je pokazivač ili referenca na objekte druge klase.
Agregacija ili sklop je takav da delovi mogu da postoje i izvan sklopa, tj. mogu da se stave u njega, vade i koriste kada nisu u sklopu. 
Sklop se sklapa pokazivačima. Delovi agregata su spojeni logički, ne fizički. Veličine objekata ne utiču na veličine agregata.
Ako delovi ne mogu da postoje izvan sklopa, onda su objekti u kompoziciji. Delovi se stvaraju i uništavaju svi zajedno, i nikako drugačije.
Delovi u kompoziciji mogu, pored pokazivačima i referencama, da se predstave poljima tipa klase delova. Tada se delovi fizički nalaze unutar objekta kompozita.
Na veličinu objekta kompozita utiče veličina svakog dela te kompozicije.

Operatori su definisani za standardne tipove, ali ne i za klasne tipove.
Zbog toga je potrebno preklopiti te operatore za klasne tipove.
Preklapanje operatora je dozvoljeno za sve operatore osim za pristup članu klase, za razrešenje dosega, za uslovni izraz, za veličinu objekata i pravljenje izuzetka.
Takođe, zabranjeno je redefinisanje operatora za standardne tipove podataka.
Za sve novuvedene tipove podataka automatski postoji tumačenje samo za operatore dodele vrednosti jednog objekta drugom, za obrazovanje adrese objekta i za obrazovanje niza izraza.
Dodela vrednosti jednog objekta drugom podrazumeva kopiranje vrednosti svih polja, osim pokazivača, između objekata istog tipa. Za njih je bolje da se koristi konstruktor kopije.
Kao i kod drugih funkcija, jedan operator može da se preklopi na više načina, ali oni moraju biti dovoljno različiti kako bi prevodilac mogao da ih razlikuje.
Operatorske funkcije mogu da budu metode klasa ili "obične" globalne funkcije (najčešće prijateljske).
Operatorske funkcije ne mogu da imaju parametre sa podrazumevanim vrednostima i ne mogu da budu zajedničke (static) metode.
Izuzeci su operatori new i delete koji mogu da budu preklopljeni samo zajedničkim metodama.
Vrednosti preklopljenih funkcija mogu da budu potpuno proizvoljnih tipova, kao i da budu tipa void.
Svejedno je da li se operatori preklapaju preko metoda ili prijateljskih funkcija.

Prefiksni oblik ++ i -- se preklapa metodom bez parametara ili globalnom funkcijom sa jednim parametrom.
Postfiksni oblik ++ i -- se preklapa metodom sa jednim parametrom ili globalnom funkcijom sa dva parametra.

Klasa za ulazne tokove se naziva istream, a za izlazne tokove ostream.

Moguće je i preklapanje operatora za konverziju tipa.
Konverziju između tipova, od kojih je bar jedan klasa, mora da definiše programer pomoću konstruktora konverzije ili preklapanjem operatora konverzije.

Operator = ima automatsko tumačenje za sve novouvedene tipove. On kopira sva statička polja, ali ne i polja iz dinamičke zone.
Svrha preklapanja operatora = je upravo obezbeđivanje kopiranja i tih polja iz dinamičke zone.
Inicijalizacija != dodela vrednosti.

Svi objekti neke podgrupe poseduju osobine svoje grupe, kao i još neke specifične osobine.
U jeziku C++ grupe objekata se opisuju pomoću klasa. One su osnovne klase [natklase].
Klase koje opisuju podgrupe neke grupe objekata se nazivaju izvedene klase [potklase].
Ovaj odnos se naziva nasleđivanje.
Jedna potklasa može da ima više nadklasa. Ovo se zove višestruko nasleđivanje. Jedna klasa može da buda natklasa od više potklasa.
Izvedena klasa nasleđuje sve članove svojih osnovnih klasa.
Konstruktori, destruktori i metoda operator=() osnovne klase se ne nasleđuju, već se generišu (ako je to potrebno).
Prijateljstvo funkcija se ne nasleđuje.

Kontrola pristupa članovima klase se ostvaruje umetanjem oznaka public, protected i private.
Javnim članovima je moguće pristupiti bez ograničenja.
Zaštićenim članovima je dozvoljen pristup iz same klase i iz svih klasa koje su iz nje izvedene (potklasa).
Privatnim članovima je dozvoljen pristup samo iz klasa čiji su članovi.
Izvođenje klase može biti može biti javno, zaštićeno ili privatno. U odstustvu modifikatora, podrazumeva se privatno nasleđivanje.
Način nasleđivanja određuje stepen konstrole pristupa članovima osnovne klase preko primeraka osnovne klase.

Pošto su strukture potpuno ravnopravne klasama, mogu da se definišu i izvedene strukture, s tim da se podrazumeva javno izvođenje, ali su mogući i private i protected.
Za unije nije moguće izvođenje.

Kompozicija: jedan objekat sadrži drugi.
Privatno/zaštićeno nasleđivanje se može videti kao jedan poseban vid kompozicije (izvedena klasa sadrži osnovnu klasu).

Osnovna klasa nikada ne zna koje su klase iz nje izvedene.
Izvedene klase tačno znaju iz kojih su klasa izvedene.

Članovima osnovnih klasa neke izvedene klase se pristupa na isti način kao i njenim sopstvenim članovima (bez navođenja identifikatora osnovne klase).
Naravno, ovo važi ako je pristup do članova osnovne klase dozvoljen (javno i zaštićeno izvođenje).
Smatra se da izvedena klasa, pored svojih članova, poseduje kao podobjekat jedan bezimeni primerak svoje osnovne klase.
Njemu se pristupa operatorom razrešenja opsega, a ne uobičajenom notacijom oblika podobjekat.član.
Ako postoje dva polja sa istim identifikatorom, za pristup polju iz osnovne klase se mora koristiti operator razrešenja opsega oblika Osnovna_klasa::član.
Redefinisanje identifikatora metoda u izvedenoj klasi se ne smatra preklapanjem imena funkcija. 
Sve metode iz osnovnih klasa sa istim imenom će postati nevidljive. Za njihovo korišćenje je neophodan operator razrešenja dosega.

Ako su dve klase izvedene iz iste klase, i ako se iz njih izvede neka treća klasa, onda će ona imati dva primerka njihove zajedničke osnovne klase.
Da bi se ovo izbeglo, prvobitna osnovna klasa treba da bude virtuelna osnovna klasa za svoje neposredno izvedene klase.
To se postiže dodavanjem modifikatora virtual ispred identifikatora osnovne klase pri definisanju izvedene klase.
U slučaju višestrukog nasleđivanja virtuelne klase naslediće se jedan zajednički podobjekat tipa te osnovne klase za sve međuklase za koje je ona virtuelna.
Za međuklase za koje nije virtuelna će se naslediti po jedan podobjekat za svaku od tih klasa.

Prilikom definisanja konstruktora za izvedenu klasu, u listi inicijalizatora pre tela konstruktora se mogu navesti i inicijalizatori za osnovne klase.
U fazi inicijalizacije primeraka klasa, nasleđena polja još nepostoje, pa ne mogu da se navedu odvojeni inicijalizatori za njih.
Moguća je samo inicijalizacija nasleđenog podobjekta kao celine.
Nasleđena polja unutar tela konstruktora mogu da se koriste pojedinačno, ali na taj način se ne vrši inicijalizacija već dodela vrednosti.

Prilikom stvaranja objekta tipa izvedene klase:
 konstruktori osnovnih klasa se izvršavaju po redosledu navođenja osnovnih klasa u definiciji izvedene klase (ne po redosledu navođenja inicijalizatora u konstruktoru)
 konstruktori polja klasnih tipova se izvršavaju po redosledu navođenja polja u definiciji izvedene klase
 inicijalizuju se polja standardnih tipova
 izvršava se telo konstruktora izvedene klase
Prilikom uništenja objekta tipa izvedene klase:
 izvršava se telo destruktora izvedene klase
 izvršavaju se destruktori polja klasnih tipova po obrnutom redosledu izvršavanja njihovih konstruktora 
 izvršavaju se destruktori osnovnih klasa po obrnutom redosledu pozivanja njihovih konstruktora

Neka polja mogu da ostanu neinicijalizovana ako se nigde ne pozove njihov inicijalizator ili im se ne dodeli vrednost.

Objekat osnovne klase može da se inicijalizuje objektom javno izvedene klase.
Tom prilikom će konstruktor kopije osnovne klase prekopirati samo polja izvedene klase koja su nasleđena od osnovne klase.
Objektu osnovne klase može da se dodeljuje vrednost objekta javno izvedene klase.
U slučaju privatnog ili zaštićenog nasleđivanja, ovo nije moguće (bar ne automatski).
Inicijalizacija objekta izvedene klase objektom osnovne klase nikada nije automatski dozvoljena. Za to mora da se definiše konverzija.
Pokazivaču na objekte osnovne klase može da se dodeli vrednost pokazivača na objekte javno izvedene klase bez eksplicitne konverzije tipa.
Ovim pokazivačem je moguće pristupiti samo nekim članovima izvedene klase (specifičnim članovima se ne može pristupiti pomoću njega).
U slučaju privatnog ili zaštićenog nasleđivanja, ovo je moguće samo uz eksplicitnu konverziju pokazivača.
Dodela vrednosti adrese osnovne klase pokazivaču izvedene klase je moguće (uz eksplicitnu konverziju), ali računaj da je zabranjeno (i pre svega glupo).
Reference se, u ovom smislu, ponašaju isto kao i pokazivači.
U prilikama kada su parametri funkcije reference na objekte, ako funkcja očekuje osnovnu klasu, i referenca na osnovnu klasu pokazuje na izvedenu klasu,
 funkcija će raditi samo sa osnovnim delom te izvedene klase (u slučaju da je nasleđivanje javno).

Konverzija nadole:  osnovna klasa  > izvedena klasa
Konverzija nagore: izvedena klasa -> osnovna klasa

Jedna od osnova OOP je polimorfizam.
Polimorfizam podrazumeva mogućnost ponašanja programa shodno tipovima obrađivanih objekata.
Virtuelna metoda je metoda osnovne klase koja može da se zameni istoimenom metodom odgovarajuće izvedene klase kada se pozove za objekat koji pripada izvedenoj klasi.
Odgovarajuća metoda iz izvedene klase se poziva čak i preko pokazivača ili referenci na objekte osnovne klase.
Prijateljske funkcije neke klase ne mogu da budu virtuelne za tu klasu (jer se ne nasleđuju !!!).
Virtuelne metode se deklarišu upotrebom modifikatora virtual na početku njihove deklaracije u osnovnoj klasi.
Prilikom ponovnog deklarisanja u izvedenim klasama, modifikator virtual se podrazumeva.
Deklaracije date virtuelne metode i u osnovnoj i u svim izvedenim klasama moraju da budu istovetne (isti broj i tipove parametara, isti tip rezultata).
Jedino se mogu razlikovati u tipu tekućeg objekta tj. tipa skrivenog parametra koje poseduju sve metode klasa (pa i virtuelne).
Prilikom pozivanja virtuelne metode pomoću pokazivača ili reference na objekte osnovne klase, pozvaće se istoimena metoda one izvedene klase čiji primerak 
 u tom momentu predstavlja dati pokazivač ili referenca.

Klase koje poseduju bar jednu virtuelnu metodu nazivaju se polimorfne klase.
Pokazivači na polimorfizne klase imaju statički i dinamički tip.
Statički tip je tip naveden u naredbi za definisanje, poznat je u vremenu prevođenja i ne može da se promeni tu toku izvršavanja programa.
Dinamički tip je pokazivač na objekte istog tipa kao i objekat na koji pokazivač pokazuje u datom trenutku.
Pomoću pokazivača mogu da se pozivaju samo metode koje postoje u klasi koja odgovara statičkom tipu (osnovnoj klasi).
Ako se desi da je pozvana metoda virtuelna, umesto nje će se pozvati istoimena metoda na osnovu dinamičkog tipa (iz odgovarajuće izvedene klase).
Statički tip pokazivača određuje šta može da se radi sa pokazanim objektom, a dinamički tip kako da se to uradi.

Data virtuelna metoda ne mora da se definiše u svim izvedenim klasama iz osnovne klase.
Ako u nekoj od izvedenih klasa ne postoji pozivana virtuelna metoda, pozvaće se virtuelna metoda osnovne klase iz koje je izvedena klasa koja poziva tu metodu.
Nije bitno kog je tipa identifikator koji se koristi za označavanje objekta.

Kod preklapanja metoda je bitno da se sve istoimene metode međusobno razlikuju dovoljno na osnovu tipova i parametara da bi prevodilac mogao da ih razlikuje.
Tipovi vrednosti metoda nisu bitne. Ovo je statički izbor pre početka izvršavanja programa. Bira se među metodama koje pripadaju istoj klasi.
Sve virtuelne metode moraju imati sve parametre istih tipova i da daju rezultat istog tipa.
Pozvana metoda se bira dinamički, u momentu pozivanja. Metoda se bira na osnovu tipa objekta na koji pokazuje ili upućuje korišćeni identifikator, a ne tip identifikatora.
Bira se među metodama koje pripadaju različitim klasama, koje sve imaju jednu zajedničku osnovnu klasu.
Ponašanje programa u polimorfizmu zavisi od tipa obrađivanog podatka, a ne od tipa identifikatora pomoću kog se dolazi do obrađivanog objekta.

Basically, ako pokazivač osnovne klase pokazuje na objekat izvedene klase, i ako se pozove neka metoda, prvo se odlazi u osnovnu klasu i gleda da li je ta metoda virtuelna.
Ako jeste, onda se ide u izvedenu klasu i poziva se verzija te metode iz vrituelne klase. Ako izvedena klasa nema tu metodu, pozvaće se metoda iz osnovne klase.
On the other hand, ako se preko pokazivača osnovne klase pozove nevirtuelna metoda, pozvaće se metoda iz osnovne klase, ne iz izvedene.
Ako se preko pokazivača osnovne klase koji pokazuje na izvedenu klasu pozove destruktor, on će uništiti samo osnovni deo te izvedene klase. To nije dobro.
U slučaju izvedenog pokazivača na izvedenu klasu, prvo se poziva izvedena metoda, a ako ona ne postoji, tek onda se odlazi u osnovnu klasu.

Konstruktori ne mogu da budu virtuelne metode.
Destruktori mogu da budu virtuelni.

Virtuelna metoda koja nije definisana u osnovnoj klasi se naziva apstraktna metoda, ili čista virtuelna metoda.
Ona umesto tela funkcije prilikom deklarisanja ima =0;
Klasa koja sadrži bar jednu apstraktnu metodu se naziva apstraktna klasa.
Ne mogu da se stvaraju objekti tipa apstraktne klase. 
Mogu da se definišu pokazivači i reference na apstraktne klase. Oni, usled nedostatka objekta osnovne klase, mogu da označavaju samo objekte tipa izvedenih klasa.
Svrha apstraktnih klasa je da se iz njih izvode druge klase.
Klasa izvedena iz apstraktne klase kojoj nedostaje definicija za bar jednu apstraktnu metodu je i sama apstraktna klasa.

Pokazivaču na osnovnu klasu može da se dodeli vrednost pokazivača na javno izvedenu klasu.
Referenca na osnovnu klasu može da se inicijalizacuje objektom javno izvedene klase.

Ako u programskom jeziku nije definisano drugačije, greške se obično razrešavaju na neke od sledećih načina:
 ako se greška desi unutar funkcije, funkcija se završava i vraća neki kod greške funkciji koja ju je pozvala
 ako se ovo slanje grešaka nastavi sve do glavne funkcije, ona se završava
 kada se dođe do funkcije koja može da reši grešku, ona je rešava i program nastavlja dalje sa radom

U jeziku C++, kada se na nekom mestu u programu otkrije greška, dovoljno je samo da se ona prijavi odgovarajućim izuzetkom.
Automatski se prekidaju započete aktivnosti i predaje upravljanje nadležnom obrađivaču izuzecima.
Može da se definiše veći broj rukovaoca, za svaki tip izuzetaka po jedan.
Rukovanje izuzecima se definiše naredbom try, koju prati obrašivač izuzetka catch koji predstavlja funkciju koja ima tačno jedan parametar.

Pojava izuzetka se prijavljuje izrazom oblika throw izraz;
Taj izraz se dostavlja rukovaocu izuzecima.
Vrednost izraza predstavlja dodatne informacije o nastalom problemu.
Ako se za neki izuzetak ne pronađe rukovaoc koji može da ga prihvati, izvršava se sistemska funkcija terminate(). Ona poziva sistemsku funkciju abort().
Klase svih izuzetaka koji se prijavljuju u jeziku C++ su izvedeni iz zajedničke osnovne klase exception.
Klasa poseduje sve metode koje se smatraju obaveznim i jednu virtuelnu metodu koja vraća pokazivač na tekstualni opis izuzetka.

U jeziku C++ postoji mogućnost definisanja šablona za opisivanje date obrade podataka za opšti slučaj, ne navodeći konkretne tipove podataka.
Šabloni mogu da se definišu i za klase u kojima se tipovi nekih polja ili parametara nekih metoda mogu kasnije konkretizovati.
Funkcije ili klase koje su opisane pomoću šablona se nazivaju generičke klase ili funkcije.
template<tip, tip, ...> opis
class - klasni tip
typename - bilo koji tip
oznaka_tipa - simboličke konstante (int, enum, pokazivač, referenca...)
Konkretne klase i funkcije na osnovu šablona mogu da se generišu i automatski i na zahtev programera.
Kod šablona generičkih klasa mogu da se predvide podrazumevane vrednosti za nekoliko poslednjih parametara.
Šabloni generičkih funkcija ne smeju da imaju parametre sa podrazumevanim vrednostima.

Metode klasa mogu da budu generičke funkcije. Same klase mogu da budu obične ili generičke klase.
Generičke metode ne mogu da budu virtuelne.
Destruktor ne može da bude generička metoda.
Konstruktor može da bude generička metoda.

STL - Standard Template Library
Standardna biblioteka sadrži često korišćene strukture podataka i funkcija za njih. Većina njih su generičke klase i funkcije, stoga i ime STL.
Svi definisani identifikatori u standardnoj biblioteci se stavljaju u prostor imena std.

Rad s tokovima u C++ se realizuje odgovarajućim klasama. Konkretni tokovi se predstavljaju pomoću primeraka tih klasa.
Klase za tokove su deo standardne biblioteke.
Klase za rad sa datotekama se nalaze u zaglavlju <fstream>.
Klase za rad s tokovima u operativnoj memoriji se nalaze u zaglavlju <sstream>.
Klase koje su zajedničke svim ovim klasama su istream i ostream koje se nalaze u zaglavlju <iostream>.
Na početku svakog programa se automatski stvaraju četiri standardna toka: cin, cout, cerr i clog.


//// JAVA ////

Java nudi veoma elegantno rešenje portabilnosti programa, tako što koristi virtuelnu mašinu.
Ona ne stimulira rad čitavog računara, nego samo neke procese.
U Javi nema destruktora. Umesto njih, sa objekta se samo skine referenca i on postane neupotrebljiv.
Java je čist objektni jezik, dok je C++ hibridni.
U Javi se objektima rukuje isključivo preko referenci (nema pokazivača).
Operacija new i dalje postoji, ali delete više ne postoji.
Pošto je Java čist objektni jezik, u njoj su sve klase. Izvedeni tipovi više ne postoje, nego su i oni posebne vrste klasa.
Ne postoji naredba typedef, niti opcija preklapanja operatora.
Nema automatske konverzije tipa u manje složeni tip. Nema slobodnih funkcija.
Ne postoji višestruko nasleđivanje.
Ne postoje generične klase.
Ne postoje skokovi (naredba goto je potpuno izbačena).
Uvedena su dva nivoa modularizacije: klase i paketi.
Uveden je logički tip (boolean?).
Metode sada mogu da vraćaju reference.
Osnovna klasa svih klasa u Javi je klasa Object i iz nje se izvode sve klase.

Virtuelna memorija se ne ponaša kao stvarna memorija.
Podeljena je na stek i hip - stek za sve skalarne promenljive i reference, a hip za sve objekte.
Ako objekat ima podobjekat, unutar objekta se nalazi referenca na taj podobjekat.

Bazni tipovi: boolean, int, long, short, byte, double, float, char (zauzima 2 bajta u Javi, ne 1)
Svi celobrojni tipovi su signed. Nemaju modifikatore unsigned isl.
Reference na objekte se ponašaju kao skalane promenljive, ali su tipa klase.
String je klasa koja je već ugrađena.
null je konstanta tipa reference.
Operacije se u Javi prepoznaju prema operandima, a ne prema simbolu operacije.

Klase u Javi nemaju public i private segmente, nego se ispred svakog polja i metode piše njihov nivo zaštite.
Logički tip je boolean i on je nekonvertibilan.
Typecast je primenljiv samo na reference.
Zabranjeno je dodeljivanje složenijeg tipa manje složenom tipu.
I nizovi su klase u Javi, i imaju ugrađenu operaciju indeksiranja. Niz se nalazi na hipu (kao i svi ostali objekti).
Java proverava proboj indeksa u svojim nizovima (u C-u se to ne proverava).
U Javi ili svi elementi imaju istu vrednost, ili ni jedan nema vrednost (u C++ neki mogu da imaju vrednost, a drugi da je nemaju).
Konkatenacija stringova je polimorfna operacija. Objekat koji se konkatenira mora imati funkciju toString().
Ako String prenesemo po referenci i menjamo ga, on će se na kraju vratiti u svoje originalno stanje.

U klasama u Javi nemamo objekte članove i podatke članove. Imamo samo polja (jer su svi klase svakako).
Svako polje u klasi će biti inicijalizovano, bez obzira da li to radimo ručno ili automatski.
Podrazumevane vrednosti za inicijalizaciju su false za boolean, null za referencu i znakovne tipove, i 0 za ostale.
Bazni tipovi se prenose isključivo po vrednosti, a objekti isključivo po adresi.
To znači da metoda radi isključivo sa originalom.
U Javi rezultat funkcije može da bude niz (jer je niz objekat, pa se vraća referenca na taj niz).
Umesto const se koristi final kada ne želimo da se nešto više menja.
Polje this postoji i u Javi ali je ovde adresa pa nema potrebe za dereferenciranjem.

U jednoj datoteci možemo imati više klasa, sa tim da je samo jedna od njih public.
Svaka klasa se instancira preko new.
Operator = ne služi za dodelu vrednosti, nego za izjednačavanje referenci.
Operator == ne upoređuje sadržaje objekata, nego njihove reference.

Statički članovi klasa mogu da se koriste bez postojanja objekta klase. Znači, pozivaju se preko klase, ne preko objekata (tada gube svoj smisao).
Statičke metode u Javi su način realizacije slobodnih funkcija.
U Javi nema globalnih promenljivih.

Private delu - pristupaju metode matične klase.
Default (friendly) delu - pristupaju metode matične klase i metode iz klasa istog paketa.
Protected delu - pristupaju metoda klasa iz tog paketa, kao i izvedene klase.
Public delu - pristupaju sve metode, bez ikakvog ograničenja.

Postoji mogućnost redefinisanja metoda. One ne smeju da se razlikuju od originalnih po imenu i parametrima.
Ne postoji višestruko nasleđivanje.
Interfejs == čisto apstraktna klasa.
Nasleđivanje klasa i redefinisanje metoda može da se spreči upotrebom modifikatora final.
Polje super je polje preko kog se može pristupiti verzijama iz bazne klase.

Potomak može da se dodeli pretku, ali obrnuto nije moguće.
U Javi se sve metode ponašaju kao virtuelne, osim ako se ne navede drugačije.

Apstraktne klase imaju modifikator abstract i ne mogu da se instanciraju.
U Javi apstraktna klasa može, a i ne mora, da sadrži apstraktne metode, nego se eksplicitno proglašava za apstraktnu.
Interfejsi nisu klase. Mogu biti public ili default. Svi članovi interfejsa su public. Omogućuju inkluzivni polimorfizam.
Interfejs ne može da se instancira, ali može da se definiše referenca na njega.
Jedna klasa može da implementira više interfejsa.

U Javi je enumeracija posebna klasa Enum.

Unutrašnje klase mogu biti public, private, protected, default i static.
Omotačke klase su Int, Long... koje pretvaraju bazne podatke u klasne podatke.

try-catch blok ima i treći deo - finally
